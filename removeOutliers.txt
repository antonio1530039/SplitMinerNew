
//I: log, l, r, K, umbral


Algorithm(int l, int r, int K, LinkedHashMap<Integer, ArrayList<Character>> traces, double umbral){
	HashMap<ArrayList<ArrayList<Character>>, SignificantContext> significantContexts = new HashMap<>();
	for(t : traces){
		ArrayList<Character> left = new ArrayList<>();
		for(int i = 0; i < t.size(); i++){
			//En este ciclo se agregan los vecinos de la izquierda
			left.add(t.get(i));

			if(left.size() == l){
				ArrayList<Character> subsequence = new ArrayList<>();
				for(int j = 0; j < t.size(); j++){
					if( i != j){
						if( j > i){
							if( ((j+1) - (i+2)) > K ){
								//a partir de j llenar right
								finishContext(left, j, (j+r), significantContexts, subsequence, t, K);
								makeChanges(significantContexts, traces, umbral);
								subsequence.removeAll();
								break;
							}else{
								subsequence.add(trace.get(j));
							}
						}else{
							if( (i+1) - (j+2) > K ){
								//a partir de i llenar right
								finishContext(left, i, (i+r), significantContexts, subsequence, t, K);
								makeChanges(significantContexts, traces, umbral);
								subsequence.removeAll();
								break;
							}else{
								subsequence.add(trace.get(j));
							}
						}
					}
				}
				left.removeAll();
			}
		}
	}
}


finishContext(ArrayList<Character> left, int start, int end, HashMap<ArrayList<ArrayList<Character>>, SignificantContext> significantContexts, ArrayList<Character> subsequence,
			 LinkedHashMap<Integer, ArrayList<Character>> traces, ArrayList<Character> actualTrace, int K){
	ArrayList<Character> right = new ArrayList<>();
	for(int z = start; z <  end; z++){
		right.add(actualTrace.get(z))
	}
	//verificar existencia de contexto y actualizar frecuencias...
	significantContexts.put(left.join(right), subsequence);

	//Para este contexto buscar todas las posibles coverturas

	for(t: traces){
		covertura = getCovertura(left, right, K, t)
		//aumentar frecuencias y agregar al mapa
		significantContexts.put(left.join(right), covertura);
	}

}


makeChanges(LinkedHashMap<HashMap<ArrayList<ArrayList<Character>>, SignificantContext> significantContexts, LinkedHashMap<Integer, ArrayList<Character>> traces, double umbral){
	for(t : traces){
		for(sc : significantContexts){
			if(sc != 'O') //si  es igual a vacino, ignorar
				if(sc exists in t && sc.probability > umbral){
					t.replace(sc.bestCover);
					//actualizar frecuencias
					SC = significantContexts.get(sc)
					SC.freq++;
					ssc = SC.subsequences.get(sc.bestCover)
					ssc.freq++;
				}
		}
	}
}


ArrayList<Character> getCovertura(ArrayList<Character> left, ArrayList<Character> right, int K, Arraylist<Character> trace){
	int x = trace.indexOf(left.get(0));
	int l = left.size();
	int r = right.size();
	int ll =0, rr=0, k=0;
	ArrayList<Character> covering = new ArrayList<>();
	while(true){
		if(ll < l){
			if(left.get(ll) == trace.get(x)){
				ll++;
				x++;
			}else{
				//no cumple con el contexto
				break;
			}
		}else if(k < K){
			covering.add(trace.get(x));
			x++;
			k++;
		}else if(rr < r){
			if(right.get(rr) == trace.get(x)){
				rr++;
				x++;
			}else{
				//no cumple con el contexto
				break;
			}
		}else{
			break;
		}	
	}

	if(rr == r && ll = l && k == k)
		return covering;
	
	covering.clear();
	covering.add('O');
	return covering;

}